module Tppr where 
-- Completar con los datos del grupo
--
-- Nombre de Grupo: xx
-- Integrante 1: Nombre Apellido, email, LU
-- Integrante 2: Nombre Apellido, email, LU
-- Integrante 3: Nombre Apellido, email, LU
-- Integrante 4: Nombre Apellido, email, LU

type Usuario = (Integer, String) -- (id, nombre)
type Relacion = (Usuario, Usuario) -- usuarios que se relacionan
type Publicacion = (Usuario, String, [Usuario]) -- (usuario que publica, texto publicacion, likes)
type RedSocial = ([Usuario], [Relacion], [Publicacion])

-- Funciones basicas

usuarios :: RedSocial -> [Usuario]
usuarios (us, _, _) = us

relaciones :: RedSocial -> [Relacion]
relaciones (_, rs, _) = rs

publicaciones :: RedSocial -> [Publicacion]
publicaciones (_, _, ps) = ps

idDeUsuario :: Usuario -> Integer
idDeUsuario (id, _) = id 

nombreDeUsuario :: Usuario -> String
nombreDeUsuario (_, nombre) = nombre 

usuarioDePublicacion :: Publicacion -> Usuario
usuarioDePublicacion (u, _, _) = u

likesDePublicacion :: Publicacion -> [Usuario]
likesDePublicacion (_, _, us) = us

-- Ejercicios

-- Predicados auxiliares
pertenece :: Eq t => t -> [t] -> Bool
pertenece n [] = False
pertenece n (x:xs) |n == x = True 
                   |otherwise = pertenece n xs


longitud :: [t] -> Integer
longitud [] = 0
longitud (x:xs) = 1 + longitud xs


amigosDe :: RedSocial -> Usuario -> [Usuario] -- (falta testear)
amigosDe x y = eliminarrepetidos (amigosDe2 (relaciones x) y)

amigosDe2 :: [Relacion] -> Usuario -> [Usuario]
amigosDe2 (x:xs) y | longitud (x:xs) == 1 = [amigosDeaux x y]
                   | pertenece y (relAusuarios x) == True = [amigosDeaux x y] ++ amigosDe2 xs y
                   | otherwise = amigosDe2 xs y

relAusuarios :: Relacion -> [Usuario]
relAusuarios (a, b) = [a, b]

amigosDeaux :: Relacion -> Usuario -> Usuario
amigosDeaux (a, b) y | a == y = b
                     | b == y = a
                     | y /= a && y /=b =y

quitartodos :: (Eq t) => t -> [t] -> [t]
quitartodos x xs | not (pertenece x xs) = xs
                 | pertenece x xs && not (hayRepetidos xs) = quitar x xs
                 | otherwise = quitartodos x (quitar x xs)

eliminarrepetidos :: (Eq t) => [t] -> [t]
eliminarrepetidos [] = []
eliminarrepetidos (x:xs) | pertenece x xs == True = x : quitartodos x xs
                         | otherwise = x : eliminarrepetidos xs 

--Necesito comparar el head con todos los elementos. Si da false lo hago con otro
hayRepetidos :: (Eq t) => [t] -> Bool
hayRepetidos ls     | longitud ls <= 1 = False
hayRepetidos (x:xs) | pertenece x xs = True
                    | otherwise= hayRepetidos (head xs:tail xs)


--Elimina primera aparicion de x en xs
quitar :: (Eq t) => t -> [t] -> [t]
quitar x xs | not (pertenece x xs) = xs
            | pertenece x xs && x == head xs = tail xs
            | otherwise = [head xs] ++ quitar x (tail xs)



-- describir qué hace la función: .....
existeSecuenciaDeAmigos :: RedSocial -> Usuario -> Usuario -> Bool
existeSecuenciaDeAmigos r u u2 | pertenece u2 (amigosDe r u) = True 
                               | not (pertenece u2 (amigosDe r u)) = False
existeSecuenciaDeAmigos r u u2 =  existeSecuenciaDeAmigosAux r  (amigosDe r u) u2 || existeSecuenciaDeAmigos r (head (amigosDe r u)) u2 


existeSecuenciaDeAmigosAux :: RedSocial -> [Usuario] -> Usuario -> Bool
existeSecuenciaDeAmigosAux _ [] _ = False
existeSecuenciaDeAmigosAux ls (x:xs) u2 | pertenece u2 (x:xs)= True
                                        | pertenece u2 (amigosDe ls x) = True
                                        | otherwise = existeSecuenciaDeAmigosAux ls xs u2 

--existeSecuenciaDeAmigos ([(3,"River"),(1,"Central")],[((1,"Central"),(2,"River")),((2,"River"),(1,"Central"))],[]]  
